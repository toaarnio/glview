#!/usr/bin/python3 -B

# pylint: disable=missing-docstring
# pylint: disable=invalid-name
# pylint: disable=c-extension-no-member
# pylint: disable=wrong-import-position
# pylint: disable=no-member
# pylint: disable=bad-whitespace

import sys                     # built-in library
import os                      # built-in library
import time                    # built-in library
import struct                  # built-in library
import pygame                  # pip install pygame
import numpy as np             # pip install numpy
import piexif                  # pip install piexif
import ModernGL                # pip install ModernGL
import imgio                   # pip install imgio

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'multiproc'))

import argv                    # local import: argv.py
import multiproc               # submodule import: multiproc.py

def main():
    numtiles = argv.intval("--split", default=1, accepted=[1, 2, 3, 4])
    raw_width, raw_height = argv.intpair("--size", default=(None, None))
    raw_bpp = argv.intval("--bpp", default=None, accepted=[8, 10, 12, 14, 16])
    showHelp = argv.exists("--help")
    argv.exitIfAnyUnparsedOptions()
    if showHelp:
        print("Usage: glview [options] [image.(pgm|ppm|png|jpg|raw)] ...")
        print()
        print("  options:")
        print("    --split 1|2|3|4     display images in N separate tiles")
        print("    --size W H          input image size in pixels (.RAW only)")
        print("    --bpp N             input image bits per pixel (.RAW only)")
        print("    --help              show this help message")
        print()
        print("  runtime:")
        print("    mouse wheel         zoom image; synchronized if multiple tiles")
        print("    mouse left + move   pan image; synchronized if multiple tiles")
        print("    PageUp/PageDown     cycle through images on active tile")
        print("    r                   rotate active tile 90 degrees clockwise")
        print("    1/2/3/4             select active tile for PageUp/PageDown/r")
        print("    s                   split window into 1/2/3/4 tiles")
        print("    f                   toggle fullscreen <-> windowed")
        print("    esc                 terminate")
        sys.exit(-1)

    filepatterns = sys.argv[1:] or ["*"]
    rawfiles, _ = argv.filenames(filepatterns, [".raw"], sort=True, allowAllCaps=True)
    use_raw = len(rawfiles) > 0
    use_raw = use_raw and not warn(use_raw and raw_bpp is None, "'--bpp N' not provided, ignoring all .RAW images.")
    use_raw = use_raw and not warn(use_raw and raw_width is None, "'--size M N' not provided, ignoring all .RAW images.")
    extensions = [".pgm", ".ppm", ".pnm", ".png", ".jpg"]
    extensions += [".raw"] if use_raw else []
    filenames, _ = argv.filenames(filepatterns, extensions, sort=True, allowAllCaps=True)
    numFiles = len(filenames)
    enforce(numFiles > 0, "No valid PGM/PPM/PNM/PNG/JPG/RAW images to show. Terminating.")
    print("See 'glview --help' for usage instructions.")

    pygame.display.init()  # pygame.audio causes interference, leave it disabled
    pygame.key.set_repeat(100, 100)  # 10 keypresses per second
    info = pygame.display.Info()
    screensize = (info.current_w, info.current_h)
    winsize = (info.current_w // 2, info.current_h // 2)
    viewports = resize(numtiles, winsize, fullscreen=False)
    ctx, prog, vao = initGL()
    N = min(numFiles, 16)
    textures = [None] * numFiles
    print("Preloading the first %d / %d images, please wait..."%(N, numFiles))
    textures[:N] = createTextures(ctx, filenames[:N], raw_width, raw_height, raw_bpp)
    ui(ctx, prog, vao, textures, filenames, screensize, winsize, viewports, numtiles, raw_width, raw_height, raw_bpp)
    pygame.quit()

def ui(ctx, prog, vao, textures, filenames, screensize, winsize, viewports, numtiles, raw_width, raw_height, raw_bpp):
    numFiles = len(filenames)
    colors = [(0.2, 0.0, 0.0), (0.0, 0.2, 0.0), (0.0, 0.0, 0.2), (0.2, 0.2, 0.0)]
    imgPerTile = [0, 0, 0, 0]
    rotPerImg = [0] * numFiles
    activeTile = 0
    fullscreen = False
    dirty = True
    stop = False
    while not stop:
        # process all pending events before redraw
        ev = pygame.event.wait()  # wait for first event
        events = [ev] + pygame.event.get()  # get all pending events
        for event in events:
            # get event type & mouse state
            quitEvent = event.type == pygame.QUIT
            resizeEvent = event.type == pygame.VIDEORESIZE
            exposeEvent = event.type == pygame.VIDEOEXPOSE
            activeEvent = event.type == pygame.ACTIVEEVENT
            keyDown = event.type == pygame.KEYDOWN
            mouseDown = event.type == pygame.MOUSEBUTTONDOWN
            mouseMotion = event.type == pygame.MOUSEMOTION
            mouseUp = event.type == pygame.MOUSEBUTTONUP
            left, mid, right = pygame.mouse.get_pressed()  # pylint: disable=unused-variable
            # get event detail
            escDown = keyDown and event.key == pygame.K_ESCAPE
            delKey = keyDown and event.key == pygame.K_DELETE
            inputFocusGain = activeEvent and event.state == 2 and event.gain is True
            mouseFocusGain = activeEvent and event.state == 1 and event.gain is True
            inputFocusLoss = activeEvent and event.state == 2 and event.gain is False
            mouseFocusLoss = activeEvent and event.state == 1 and event.gain is False
            pageUpDown = keyDown and event.key in [pygame.K_PAGEUP, pygame.K_KP9]
            pageDownDown = keyDown and event.key in [pygame.K_PAGEDOWN, pygame.K_KP3]
            numberKeyDown = keyDown and pygame.K_1 <= event.key <= pygame.K_4
            toggleFullscreen = keyDown and event.key == pygame.K_f
            cycleNumTiles = keyDown and event.key == pygame.K_s
            rotate90CW = keyDown and event.key == pygame.K_r
            wheelRollDown = mouseDown and event.button == 5
            wheelRollUp = mouseDown and event.button == 4
            leftDown = mouseDown and event.button == 1
            leftUp = mouseUp and event.button == 1
            mouseRelPos = pygame.mouse.get_rel()
            # take action based on mouse state & event
            stop = stop or quitEvent or escDown
            if delKey and numtiles == 1:
                imgidx = imgPerTile[activeTile]
                filename = filenames[imgidx]
                del textures[imgidx]
                del filenames[imgidx]
                os.remove(filename)
                print("Deleted %s."%(filename))
                numFiles -= 1
                enforce(numFiles >= 1, "No images to display. Terminating.")
                imgidx = min(imgidx, numFiles - 1)
                imgPerTile[activeTile] = imgidx
                dirty = True
            if numberKeyDown and numtiles > 1:
                numberKey = event.key - pygame.K_1
                activeTile = numberKey if numberKey < numtiles else activeTile
            if toggleFullscreen:
                dirty = True
                if not fullscreen:
                    prevWinsize = winsize
                    winsize = screensize
                    viewports = resize(numtiles, screensize, fullscreen=True)
                    fullscreen = True
                else:
                    winsize = prevWinsize
                    viewports = resize(numtiles, winsize, fullscreen=False)
                    fullscreen = False
            if cycleNumTiles:
                dirty = True
                numtiles = (numtiles % 4) + 1  # 1,2,3,4,1,2,3,4,...
                viewports = resize(numtiles, winsize, fullscreen=fullscreen)
                activeTile = min(activeTile, numtiles - 1)
            if rotate90CW:
                dirty = True
                imgidx = imgPerTile[activeTile]
                rotPerImg[imgidx] += 90
                rotPerImg[imgidx] %= 360
            if resizeEvent:
                dirty = True
                winsize = prevWinsize = event.size
                viewports = resize(numtiles, winsize, fullscreen=False)
            if pageUpDown or pageDownDown:
                dirty = True
                incr = 1 if pageDownDown else -1 if pageUpDown else 0
                imgidx = imgPerTile[activeTile]
                imgidx = (imgidx + incr) % numFiles
                imgPerTile[activeTile] = imgidx
            if leftDown:  # switch to virtual mouse mode
                pygame.mouse.set_visible(False)
                pygame.event.set_grab(True)
            if leftUp:  # switch back to normal mouse mode
                pygame.mouse.set_visible(True)
                pygame.event.set_grab(False)
                pygame.mouse.set_pos((winsize[0] / 2, winsize[1] / 2))
            if wheelRollDown or wheelRollUp:
                dirty = True
                scaleFactor = 1.0 + 0.1 * wheelRollDown - 0.1 * wheelRollUp
                prog.uniforms['scale'].value *= scaleFactor
            if mouseMotion and left:
                if 0 < np.linalg.norm(mouseRelPos) < 200:  # filter out pygame glitches & no-ops
                    dirty = True
                    imgidx = imgPerTile[activeTile]
                    imgw = textures[imgidx].width
                    imgh = textures[imgidx].height
                    ooScale = 1.0 / prog.uniforms['scale'].value
                    posX, posY = prog.uniforms['mousepos'].value
                    posX += mouseRelPos[0] * 8.0 * ooScale / imgw
                    posY -= mouseRelPos[1] * 8.0 * ooScale / imgh
                    posX = np.clip(posX, -1.0, 1.0)
                    posY = np.clip(posY, -1.0, 1.0)
                    prog.uniforms['mousepos'].value = (posX, posY)
        if dirty:
            dirty = False
            caption = "glview "
            for i in range(numtiles):
                imgidx = imgPerTile[i]
                if textures[imgidx] is None:
                    textures[imgidx] = createTexture(ctx, filenames[imgidx], raw_width, raw_height, raw_bpp)
                texture = textures[imgidx]
                texture.use()
                orientation = rotPerImg[imgidx]
                texw, texh = texture.width, texture.height
                texw, texh = (texh, texw) if orientation in [90, 270] else (texw, texh)
                vpx, vpy, vpw, vph = viewports[i]
                ctx.viewport = viewports[i]
                ctx.clear(*colors[i], viewport=viewports[i])
                xscale, yscale = getAspectRatio(vpw, vph, texw, texh)
                prog.uniforms['orientation'].value = orientation
                prog.uniforms['aspect'].value = (xscale, yscale)
                prog.uniforms['grayscale'].value = (texture.components == 1)
                vao.render(ModernGL.TRIANGLE_STRIP)
                caption = "%s | %d/%d: %s"%(caption, imgidx + 1, numFiles, filenames[imgidx])
            pygame.display.set_caption(caption)
            pygame.display.flip()

def initGL():
    ctx = ModernGL.create_context()
    ctx.enable(ModernGL.DEPTH_TEST)
    shaderPath = os.path.dirname(os.path.realpath(__file__))
    vshader = ctx.vertex_shader(open(os.path.join(shaderPath, 'panzoom.vs')).read())
    fshader = ctx.fragment_shader(open(os.path.join(shaderPath, 'texture.fs')).read())
    prog = ctx.program([vshader, fshader])
    prog.uniforms['scale'].value = 1.0
    prog.uniforms['orientation'].value = 0
    prog.uniforms['mousepos'].value = (0.0, 0.0)
    vbo = ctx.buffer(struct.pack('8f', -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0))
    vao = ctx.simple_vertex_array(prog, vbo, ['vert'])
    return ctx, prog, vao

def createTexture(ctx, filename, raw_width, raw_height, raw_bpp):
    img = loadImage(filename, raw_width, raw_height, raw_bpp)
    h, w = img.shape[:2]
    isFloat = img.itemsize >= 4
    if img.ndim == 3:  # RGB
        texture = ctx.texture((w, h), 3, img.flatten(), floats=isFloat)
    if img.ndim == 2:  # grayscale
        texture = ctx.texture((w, h), 1, img.flatten(), floats=isFloat)
    texture.filter = ModernGL.NEAREST
    return texture

def createTextures(ctx, filenames, raw_width, raw_height, raw_bpp):
    t0 = time.time()
    textures = []
    totalSize = 0
    n = 100
    filegroups = [filenames[i*n:i*n+n] for i, _ in enumerate(filenames[::n])]
    for filegroup in filegroups:
        args = [(filename, raw_width, raw_height, raw_bpp) for filename in filegroup]
        images = multiproc.run(loadImage, args, raise_exceptions=False)
        for idx, img in enumerate(images):
            if img is None:
                raise ValueError("Failed to load '%s'. Terminating."%(filegroup[idx]))
            else:
                h, w = img.shape[:2]
                isFloat = img.itemsize >= 4
                if img.ndim == 3:  # RGB
                    texture = ctx.texture((w, h), 3, img.flatten(), floats=isFloat)
                if img.ndim == 2:  # grayscale
                    texture = ctx.texture((w, h), 1, img.flatten(), floats=isFloat)
                texture.filter = ModernGL.NEAREST
                textures.append(texture)
                totalSize += img.nbytes
    elapsed = time.time() - t0
    totalSize = totalSize / 1024**2
    bandwidth = totalSize / elapsed
    print("Copied %d MB of image data from disk to OpenGL in %.1f seconds (%d MB/sec)."%(totalSize, elapsed, bandwidth))
    return textures

def loadImage(filespec, raw_width, raw_height, raw_bpp):
    # This function is run in a separate process, so we can't access
    # the GL context here. Otherwise we could upload the texture as
    # soon as it's loaded, rather than having to memcpy it across the
    # process boundary.
    img, maxval = imgio.imread(filespec, raw_width, raw_height, raw_bpp, verbose=True)
    if img.ndim == 3:  # RGB
        img = img[:, :, :3]  # scrap alpha channel, if any
    if maxval == 255:
        img = img.astype(np.uint8)
    else:
        img = img.astype(np.float32) / maxval
        img = (img * 255).astype(np.uint8)
    basename, filetype = os.path.splitext(filespec)
    for jpeg_ext in [".jpg", ".jpeg", ".JPG", ".JPEG"]:
        jpeg_file = basename + jpeg_ext
        if os.path.exists(jpeg_file):
            img = rotateByExif(img, jpeg_file)
            break
    return img

def rotateByExif(img, jpeg_filespec):
    exif_dict = piexif.load(jpeg_filespec).pop("0th")
    orientation = exif_dict.get(piexif.ImageIFD.Orientation)
    if orientation == 3:        # 180
        img = np.rot90(img, 2)
    if orientation == 6:
        img = np.rot90(img, 3)  # 90 CW
    if orientation == 8:
        img = np.rot90(img)     # 90 CCW
    return img

def resize(numtiles, winsize, fullscreen):
    windowType = (pygame.FULLSCREEN | pygame.HWSURFACE) if fullscreen else pygame.RESIZABLE
    pygame.display.set_mode(winsize, pygame.OPENGL | pygame.DOUBLEBUF | windowType)
    w, h = winsize
    viewports = {}
    if numtiles == 1:
        vpw, vph = (w, h)
        viewports[0] = (0, 0, w, h)
    elif numtiles == 2:
        vpw, vph = (w // 2, h)
        viewports[0] = (0,   0, vpw, vph)
        viewports[1] = (vpw, 0, vpw, vph)
    elif numtiles == 3:
        vpw, vph = (w // 3, h)
        viewports[0] = (0,       0, vpw, vph)
        viewports[1] = (vpw,     0, vpw, vph)
        viewports[2] = (2 * vpw, 0, vpw, vph)
    elif numtiles == 4:
        vpw, vph = (w // 2, h // 2)
        viewports[0] = (0,   vph, vpw, vph)  # bottom left => top left
        viewports[1] = (vpw, vph, vpw, vph)  # bottom right => top right
        viewports[2] = (0,   0,   vpw, vph)  # top left => bottom left
        viewports[3] = (vpw, 0,   vpw, vph)  # top right => bottom right
    return viewports

def getAspectRatio(vpw, vph, texw, texh):
    vpAspect = vpw / vph
    texAspect = texw / texh
    if texAspect > vpAspect:
        # image wider than window => squeeze y => black top & bottom
        xscale, yscale = (1.0, vpAspect / texAspect)
    else:
        # image narrower than window => squeeze x => black sides
        xscale, yscale = (texAspect / vpAspect, 1.0)
    return xscale, yscale

def enforce(expression, messageIfFalse):
    if not expression:
        print(messageIfFalse)
        sys.exit(-1)

def warn(expression, messageIfTrue):
    if expression:
        print(messageIfTrue)
    return expression

if __name__ == "__main__":
    main()
